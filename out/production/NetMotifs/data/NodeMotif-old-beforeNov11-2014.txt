package data;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import com.google.common.collect.Sets;

public class NodeMotif {
	public int id;
	public int label;// 0 or 1, 0 -> y = -1; 1 -> y = 0 or 1;
	public int y;
	public double t; // time signed up
	public int infreq; 
	public int outfreq;
	public Set<Integer> slist = new HashSet<Integer>();
	public Set<Integer> rlist = new HashSet<Integer>();
	public Set<Integer> mlist = new HashSet<Integer>();
	public Set<Integer> nlist = new HashSet<Integer>();
	public HashMap<Integer, Integer> motif = new HashMap<Integer, Integer>();
	
	public HashMap<Integer, Integer> comFreq = new HashMap<Integer, Integer>();
	// helper function to count call frequency
	public void countFreq(int id){
		if(this.comFreq.get(id) != null){
			this.comFreq.put(id, this.comFreq.get(id) + 1);
		}else{
			this.comFreq.put(id,  1);
		}
	}
	
	// initialization with known negative outcome
	public NodeMotif(int id){
		this.id = id;
		this.y = 0;
		this.label = 0;
		this.t = 0;
	}

	// initialization with outcome and label
	public NodeMotif(int id, double t, int y, int label){
		this.id = id;
		this.t = t;
		this.y = y;
		this.label = label;
	}

	public void reset(){
		this.slist = new HashSet<Integer>();
		this.rlist = new HashSet<Integer>();
		this.nlist = new HashSet<Integer>();
		this.mlist = new HashSet<Integer>();
		this.comFreq = new HashMap<Integer, Integer>();
	}

	// add receiver
	public void sendto(Integer n){
		if(this.id == n){return;}
		this.slist.add(n);
		this.nlist.add(n);
		this.countFreq(n);
	}
	// add sender
	public void recfrom(Integer n){
		if(this.id == n){return;}
		this.rlist.add(n);
		this.nlist.add(n);
		this.countFreq(n);
	}
	
	// this should come before organize
	public void thinFreq(int n){
		HashSet<Integer> remain = new HashSet<Integer>();
		for(int node : this.comFreq.keySet()){
			if(this.comFreq.get(node) >= n) remain.add(node);
		}
		this.rlist = Sets.intersection(this.rlist, remain);
		this.slist = Sets.intersection(this.slist,  remain);
	}
	
	// get mutual and neighbor
	public void organize(){
		this.mlist = Sets.intersection(this.slist, this.rlist);
		this.slist = Sets.difference(this.slist,  this.mlist);
		this.rlist = Sets.difference(this.rlist,  this.mlist);
	}

	// helper function to get the list needed
	// indicators: s-1, r-2, m-3, n-4
	public Set<Integer> getNei(int t0){
		Set<Integer> toget = new HashSet<Integer>();
		if(t0 == 1){
			toget = this.slist;
		}else if(t0 == 2){
			toget = this.rlist;
		}else if(t0 == 3){
			toget = this.mlist;
		}else if(t0 == 4){
			toget = this.nlist;
		}
		// else return all neighbors
		return(toget);
	}
	
	
	// helper function to get the list needed, with specified Y value
	// indicators: s-1, r-2, m-3, n-4
	public Set<Integer> getNei(int t0, int label, HashMap<Integer, NodeMotif> nodes){
		Set<Integer> toget = new HashSet<Integer>();
		if(t0 == 1){
			toget = this.slist;
		}else if(t0 == 2){
			toget = this.rlist;
		}else if(t0 == 3){
			toget = this.mlist;
		}else if(t0 == 4){
			toget = this.nlist;
		}		
		Set<Integer> toreturn = new HashSet<Integer>();
		for(int node : toget){
			if(nodes.get(node).label == label){
				toreturn.add(node);
			}
		}
		// else return all neighbors
		return(toreturn);
	}


	// helper function to get 2-hop friends, 
	//   i.e., type-t0-friend's type-t1-friend
	private Set<Integer> get2hop(HashMap<Integer, NodeMotif> nodes, int t0, int t1){
		Set<Integer> hop2 = new HashSet<Integer>();
		Set<Integer> hop1 = this.getNei(t0);
		for(int nei1 : hop1){
			hop2.addAll(nodes.get(nei1).getNei(t1));
		}
		Set<Integer> temp = new HashSet<Integer>();
		temp.add(this.id);
		hop2 = Sets.difference(hop2, temp);
		return(hop2);
	}

	// helper function to get 2-hop friends, with specified y values 
	//   i.e., type-t0-friend's type-t1-friend
	private Set<Integer> get2hop(HashMap<Integer, NodeMotif> nodes, int t0, int t1, int label0, int label1){
		Set<Integer> hop2 = new HashSet<Integer>();
		Set<Integer> hop1 = this.getNei(t0, label0, nodes);
		for(int nei1 : hop1){
			hop2.addAll(nodes.get(nei1).getNei(t1, label1, nodes));
		}
		Set<Integer> temp = new HashSet<Integer>();
		temp.add(this.id);
		hop2 = Sets.difference(hop2, temp);
		return(hop2);
	}

	// helper function to count isolated nodes.
	//  i.e. how many nodes only has you alone as friend of any type
	//       and the node itself has to have only one friend too
	private int countISO(HashMap<Integer, NodeMotif> nodes, int t0){
		int iso = 0;
		Set<Integer> friends = getNei(t0);
		if(friends.size() > 1){
			return(0);
		}
		for(int fri : friends){
			if(nodes.get(fri).nlist.size() == 1) iso++;
		}
		return(iso);
	}

	// helper function to count isolated nodes and satisfy given Y value.
	//  i.e. how many nodes only has you alone as friend of any type
	//       and the node itself has to have only one friend too
	private int countISO(HashMap<Integer, NodeMotif> nodes, int t0, int label){
		int iso = 0;
		Set<Integer> friends = getNei(t0);
		if(friends.size() > 1){
			return(0);
		}
		for(int fri : friends){
			if(nodes.get(fri).nlist.size() == 1 & nodes.get(fri).label == label) iso++;
		}
		return(iso);
	}
	
	// helper function to count [new] isolated nodes and satisfy given Y value.
	//  i.e. how many nodes only has you alone as friend of any type
	//       but you could have more than one friend
	private int countISO_new(HashMap<Integer, NodeMotif> nodes, int t0, int label){
		int iso = 0;
		Set<Integer> friends = getNei(t0);
		for(int fri : friends){
			if(nodes.get(fri).nlist.size() == 1 & nodes.get(fri).label == label) iso++;
		}
		return(iso);
	}

	// calculate node motifs
	public void motifCount(HashMap<Integer, NodeMotif> nodes){
		// if iso by itself, return with type 0
		if(this.nlist.size() == 0){
			this.motif.put(0,  1);
			for(int i = 1; i < 34; i++){this.motif.put(i, 0);}
			return;
		}else{
			this.motif.put(0,  0);
		}
		Set<Integer> mm = get2hop(nodes, 3,3);
		Set<Integer> ms = get2hop(nodes, 3,1);
		Set<Integer> mr = get2hop(nodes, 3,2);
		Set<Integer> sm = get2hop(nodes, 1,3);
		Set<Integer> ss = get2hop(nodes, 1,1);
		Set<Integer> sr = get2hop(nodes, 1,2);
		Set<Integer> rm = get2hop(nodes, 2,3);
		Set<Integer> rs = get2hop(nodes, 2,1);
		Set<Integer> rr = get2hop(nodes, 2,2);

		this.motif.put(33, Sets.intersection(this.mlist, mm).size() / 2 );
		this.motif.put(32, Sets.intersection(this.slist, mm).size()     );
		this.motif.put(31, Sets.intersection(this.rlist, mm).size()     );
		this.motif.put(30, Sets.intersection(this.slist, sm).size() / 2 );
		this.motif.put(29, Sets.intersection(this.rlist, rm).size() / 2 );
		this.motif.put(28, Sets.intersection(this.rlist, sm).size()     );

		this.motif.put(27, Sets.intersection(this.slist, mr).size()     );
		this.motif.put(26, Sets.intersection(this.rlist, mr).size()     );
		this.motif.put(25, Sets.intersection(this.rlist, ss).size()     );

		this.motif.put(24, Sets.intersection(this.mlist, ms).size()     );
		this.motif.put(23, Sets.intersection(this.slist, ms).size()     );
		this.motif.put(22, Sets.intersection(this.rlist, ms).size()     );
		this.motif.put(21, Sets.intersection(this.slist, ss).size()     );
		this.motif.put(20, Sets.intersection(this.rlist, rs).size()     );
		this.motif.put(19, Sets.intersection(this.rlist, sr).size()     );

		this.motif.put(18, this.mlist.size() * (this.mlist.size() - 1) / 2 
				- this.motif.get(33) - this.motif.get(24));
		this.motif.put(17, this.mlist.size() * this.slist.size() 
				- this.motif.get(23) - this.motif.get(27)- this.motif.get(32));
		this.motif.put(16, this.mlist.size() * this.rlist.size()
				- this.motif.get(22) - this.motif.get(26)- this.motif.get(31));
		this.motif.put(15, this.slist.size() * (this.slist.size() - 1 ) / 2 
				- this.motif.get(21) - this.motif.get(30));
		this.motif.put(14, this.rlist.size() * (this.rlist.size() - 1 ) / 2 
				- this.motif.get(20) - this.motif.get(29));
		this.motif.put(13, this.slist.size() * this.rlist.size() 
				- this.motif.get(19) - this.motif.get(25) - this.motif.get(28));

		//		if(this.motif.get(18) < 0){
		//			System.out.println(18);
		//			System.out.println( this.mlist.size()  );
		//			System.out.println(this.motif.get(33));
		//			System.out.println(this.motif.get(24));
		//		}
		//		if(this.motif.get(17) < 0) System.out.println(17);
		//		if(this.motif.get(16) < 0) System.out.println(16);
		//		if(this.motif.get(15) < 0) System.out.println(15);
		//		if(this.motif.get(14) < 0) System.out.println(14);
		//		if(this.motif.get(13) < 0) System.out.println(13);
		//		

		this.motif.put(12, Sets.difference(mm, this.nlist).size());
		this.motif.put(11, Sets.difference(sm, this.nlist).size());
		this.motif.put(10, Sets.difference(rm, this.nlist).size());
		this.motif.put(9, Sets.difference(mr, this.nlist).size());
		this.motif.put(8, Sets.difference(sr, this.nlist).size());
		this.motif.put(7, Sets.difference(rr, this.nlist).size());
		this.motif.put(6, Sets.difference(ms, this.nlist).size());
		this.motif.put(5, Sets.difference(ss, this.nlist).size());
		this.motif.put(4, Sets.difference(rs, this.nlist).size());

		this.motif.put(3, countISO(nodes, 3));
		this.motif.put(2, countISO(nodes, 1));
		this.motif.put(1, countISO(nodes, 2));

	}

	// calculate dyad motifs
	public void dyadCount2(HashMap<Integer, NodeMotif> nodes){		
		this.motif.put(1,  countISO(nodes, 2, 0));
		this.motif.put(2,  countISO(nodes, 2, 1));
		this.motif.put(3,  countISO(nodes, 1, 0));
		this.motif.put(4,  countISO(nodes, 1, 1));
		this.motif.put(5,  countISO(nodes, 3, 0));
		this.motif.put(6,  countISO(nodes, 3, 1));
	}
	
	// calculate dyad motifs with new definition
	public void dyadCount2_new(HashMap<Integer, NodeMotif> nodes){		
		this.motif.put(1,  countISO_new(nodes, 2, 0));
		this.motif.put(2,  countISO_new(nodes, 2, 1));
		this.motif.put(3,  countISO_new(nodes, 1, 0));
		this.motif.put(4,  countISO_new(nodes, 1, 1));
		this.motif.put(5,  countISO_new(nodes, 3, 0));
		this.motif.put(6,  countISO_new(nodes, 3, 1));
	}

	// calculate three-node motifs
	public void triCount(HashMap<Integer, NodeMotif> nodes, int label0, int label1){
		// this counts the "left" angle
		Set<Integer> mm = get2hop(nodes, 3,3, label0, label1);
		Set<Integer> ms = get2hop(nodes, 3,1, label0, label1);
		Set<Integer> mr = get2hop(nodes, 3,2, label0, label1);
		Set<Integer> sm = get2hop(nodes, 1,3, label0, label1);
		Set<Integer> ss = get2hop(nodes, 1,1, label0, label1);
		Set<Integer> sr = get2hop(nodes, 1,2, label0, label1);
		Set<Integer> rm = get2hop(nodes, 2,3, label0, label1);
		Set<Integer> rs = get2hop(nodes, 2,1, label0, label1);
		Set<Integer> rr = get2hop(nodes, 2,2, label0, label1);

		// divider for homophily graph
		int homo = 1;
		if(label0 == label1){
			homo = 2;
		}
		this.motif.put(118 + label0 + label1, 
				Sets.intersection(this.mlist, mm).size() / homo );
		this.motif.put(114 + 2 * label0 + label1, 
				Sets.intersection(this.slist, mm).size()     );
		this.motif.put(110 + 2 * label0 + label1 , 
				Sets.intersection(this.rlist, mm).size()     );
		this.motif.put(107 + label0 + label1, 
				Sets.intersection(this.slist, sm).size() / homo );
		this.motif.put(104 + label0 + label1, 
				Sets.intersection(this.rlist, rm).size() / homo );
		this.motif.put(100 + 2 * label0 + label1, 
				Sets.intersection(this.slist, rm).size()     );

		this.motif.put(96 + 2 * label0 + label1, 
				Sets.intersection(this.slist, mr).size()     );
		this.motif.put(92 + 2 * label0 + label1, 
				Sets.intersection(this.rlist, mr).size()     );
		this.motif.put(88 + 2 * label0 + label1, 
				Sets.intersection(this.slist, rr).size()     );

		this.motif.put(84 + 2 * label0 + label1, 
				Sets.intersection(this.mlist, ms).size()     );
		this.motif.put(80 + 2 * label0 + label1, 
				Sets.intersection(this.slist, ms).size()     );
		this.motif.put(76 + 2 * label0 + label1, 
				Sets.intersection(this.rlist, ms).size()     );
		this.motif.put(72 + 2 * label0 + label1, 
				Sets.intersection(this.slist, ss).size()     );
		this.motif.put(68 + 2 * label0 + label1, 
				Sets.intersection(this.rlist, rs).size()     );
		this.motif.put(64 + 2 * label0 + label1, 
				Sets.intersection(this.slist, rs).size()     );

		// if homo, N1 = N2, the total count is N1 * (N2 -1) / 2
		// if not homo, it is N1 * N2
		/* the factor is a counter for symmetric cases
		/* if label0 = label1 = 1, the term to be subtracter should have index (2*label0 + label1)
		/* if (0,1) or (1,0), it should be both (label0 + label1) + (label0 + label1 + 1)
		 * 		then to avoid using motifs not counted yet, need to count only (label0 + label1), 
		 * 			and adjust the other one later.
		 * Not also the factor is not applied to the last line of motifs, since they are also symmetric.
		 * So we need the factor to help find the correct index.	
		 */
		int fac = label0 + label1;
		this.motif.put(61 + label0 + label1, 
				this.getNei(3, label0, nodes).size() 
				* (this.getNei(3, label1, nodes).size() - homo + 1) / homo 
				- this.motif.get(84 + fac * label0 + label1) - this.motif.get(118 + label0 + label1));

		this.motif.put(57 + 2 * label0 + label1, 
				this.getNei(3, label0, nodes).size() 
				* this.getNei(1, label1, nodes).size() 
				- this.motif.get(80 + 2 * label0 + label1) - this.motif.get(96 + 2 * label0 + label1)- this.motif.get(114 + 2 * label0 + label1));

		this.motif.put(53 + 2 * label0 + label1, 
				this.getNei(3, label0, nodes).size() 
				* this.getNei(2, label1, nodes).size()
				- this.motif.get(76 + 2 * label0 + label1) - this.motif.get(92 + 2 * label0 + label1)- this.motif.get(110 + 2 * label0 + label1 ));

		this.motif.put(50 + label0 + label1, 
				this.getNei(1, label0, nodes).size() 
				* (this.getNei(1, label1, nodes).size() - homo + 1 ) / homo
				- this.motif.get(72 + fac * label0 + label1) - this.motif.get(107 + label0 + label1));

		this.motif.put(47 + label0 + label1, 
				this.getNei(2, label0, nodes).size() 
				* (this.getNei(2, label1, nodes).size() - homo + 1 ) / homo 
				- this.motif.get(68 + fac * label0 + label1) - this.motif.get(104 + label0 + label1));

		this.motif.put(43 + 2 * label0 + label1, 
				this.getNei(2, label0, nodes).size() 
				* this.getNei(1, label1, nodes).size() 
				- this.motif.get(64 + 2 * label0 + label1) - this.motif.get(88 + 2 * label0 + label1) - this.motif.get(100 + 2 * label0 + label1));

		// adjust for symmetric case when first label and second label not equal
		/* i.e. for type 62, counting 0 <-> A <-> 1
		 *  it should be |A<->0| * |A<->1| - type 85 - type 86 - type 119
		 *  the calculation above only subtracts type 85 and type 119
		 *  
		 *  since only the second time (0, 1) or (1, 0) is called that we know how to adjust
		 */

		if(label0 > label1){
			this.motif.put(62, this.motif.get(62) - this.motif.get(86));
			this.motif.put(51,  this.motif.get(51) - this.motif.get(74));
			this.motif.put(48,  this.motif.get(48) - this.motif.get(70));
		}

		// here we could only use nlist, since the previous set considers label
		this.motif.put(39+ 2 * label0 + label1, Sets.difference(mm, this.nlist).size());
		this.motif.put(35+ 2 * label0 + label1, Sets.difference(sm, this.nlist).size());
		this.motif.put(31+ 2 * label0 + label1, Sets.difference(rm, this.nlist).size());
		this.motif.put(27+ 2 * label0 + label1, Sets.difference(mr, this.nlist).size());
		this.motif.put(23+ 2 * label0 + label1, Sets.difference(sr, this.nlist).size());
		this.motif.put(19+ 2 * label0 + label1, Sets.difference(rr, this.nlist).size());
		this.motif.put(15+ 2 * label0 + label1, Sets.difference(ms, this.nlist).size());
		this.motif.put(11+ 2 * label0 + label1, Sets.difference(ss, this.nlist).size());
		this.motif.put(7 + 2 * label0 + label1, Sets.difference(rs, this.nlist).size());
	}

	// calculate motifs with label
	public void motifCount_wlabel(HashMap<Integer, NodeMotif> nodes){
		// if iso by itself, return with type 0
		if(this.nlist.size() == 0){
			this.motif.put(0,  1);
			for(int i = 1; i < 121; i++){this.motif.put(i, 0);}
			return;
		}else{
			this.motif.put(0,  0);
		}

		this.dyadCount2_new(nodes);

		/*
		 * the order to call (0,1) and (1,0) should not be changed!
		 */
		this.triCount(nodes, 0, 0);
		this.triCount(nodes, 0, 1);			
		this.triCount(nodes, 1, 0);
		this.triCount(nodes, 1, 1);
	}

	public void printto(BufferedWriter sc, int nvar) throws IOException{
		StringBuilder sb = new StringBuilder();
		sb.append(this.y);
		sb.append(",");
		sb.append(this.t);
		sb.append(",");
		for(int i = 0; i < nvar - 1; i++){
			sb.append(this.motif.get(i));
			sb.append(",");
		}
		sb.append(this.motif.get(nvar - 1));
		
		// add columns to check outlier is indeed removed
		sb.append(",");
		sb.append(this.infreq + ",");
		sb.append(this.outfreq + ",");
		sb.append(this.slist.size() + ",");
		sb.append(this.rlist.size() + ",");
		sb.append(this.mlist.size() + ",");
		sb.append(this.nlist.size() );
		sb.append("\n");
		sc.write(sb.toString());
	}

}
